//
//  Sort.cpp
//  AlgorithmNote
//
//  Created by Joe on 2022/3/2.
//

#include "Sort.hpp"

/*
 插入排序：对序列a的n个元素a[1] ~ a[n]，令i 从2到n枚举，进行n-1趟操作，假设某一趟时，序列a的前i-1个元素a[1] ~ a[i-1]已经有序，而范围[i, n]未有序，那么该趟从范围[1,i-1]
 中寻找某个位置j，使得将a[i]插入位置j后（此时a[j] ~ a[i-1]会后移一位到a[j+1] ~ a[i]）,范围[1,i]有序。
 int a[5] = {3, 4, 1, 5, 2};按照从小到大的顺序排列
 1、第一趟结果：{3, 4, 1, 5, 2}：有序部分{3},需要把下一个元素{4}插入到有序部分{3}中，显然插入位置在{3}后面，形成新的有序部分{3，4}
 2、第二趟结果：{1, 3, 4, 5, 2}：有序部分{3,4},需要把下一个元素{1}插入到有序部分{3,4}中，显然插入位置在{3}前面，形成新的有序部分{1,3,4}
 3、第三趟结果：{1, 3, 4, 5, 2}：有序部分{1,3,4},需要把下一个元素{5}插入到有序部分{1,3,4}中，显然插入位置在{4}后面，形成新的有序部分{1,3,4,5}
 4、第四趟结果：{1, 2, 3, 4, 5}：有序部分{1,3,4,5},需要把下一个元素{2}插入到有序部分{1,3,4,5}中，显然插入位置在{1}后面，形成新的有序部分{1, 2, 3, 4, 5}，结束排序
 思路：总共进行n-1趟操作，每一步将一个待排序的元素，按其排序码的大小，插入到前面已经排好序的一组元素的适当位置上去，直到元素全部插入为止。
 */
void insertSort() {
    int a[5] = {3, 4, 1, 5, 2};
    for (int i = 1; i < 5; i++) { // 进行n-1趟排序
        if (a[i] < a[i - 1]) {
            int temp = a[i],j = i; // temp临时存放a[i],j从i开始往前枚举
            while (j > 0 && a[j - 1] > temp) { // 只要temp小于前一个元素a[j - 1]
                a[j] = a[j - 1]; // 把a[j - 1]后移一位到a[j]
                j--;
            }
            a[j] = temp;// 插入位置j
        }
        
    }
    for (int i = 0; i < 5; i++) {
        printf("%d ",a[i]);
    }
}
/*
 选择排序：对一个序列A中的元素A[0] ~ A[n-1]，令i从0到n-1枚举，进行n趟操作，每趟从待排序部分[i,n]中选择最小的元素，令其待排序部分的第一个元素与A[i]进行交换，
 这样元素A[i]就会与当前有序区间[0, i-1]形成新的有序区间[1, i]，进行n趟操作后，所有元素就是有序的。
 int a[5] = {3, 4, 1, 5, 2};按照从小到大的顺序排列
 1、交换第一趟结果：{1, 4, 3, 5, 2}：待排序部分{3, 4, 1, 5, 2}中选出最小值{1}，再和第一个元素{3}比较最小并交换位置
 2、交换第二趟结果：{1, 2, 3, 5, 4}：待排序部分{4, 3, 5, 2}中选出最小值{2}，再和第一个元素{4}比较最小并交换位置
 3、交换第三趟结果：{1, 2, 3, 5, 4}：待排序部分{3, 5, 4}中选出最小值{3}，属于自身，不需要交换位置.
 4、交换第四趟结果：{1, 2, 3, 4, 5}：待排序部分{5, 4}中选出最小值{4}，再和第一个元素{5}比较最小并交换位置.
 思路：总共进行n趟操作，每趟操作选出待排序部分[i,n]中最小的元素，令其与A[i]交换。
 */
void selectSort() {
    int a[5] = {3, 4, 1, 5, 2};
    for (int i = 0; i < 5; i++) { // 进行n趟操作
        int k = i;
        for (int j = i; j < 5; j++) { // 选出[i, n]中最小的元素，下标为k
            if (a[j] < a[k]) {
                k = j;
            }
        }
        int temp = a[i];
        a[i] = a[k];
        a[k] = temp;
    }
    
    for (int i = 0; i < 5; i++) {
        printf("%d ",a[i]);
    }
}
/*
 冒泡排序：本质在于交换，即每次通过交换的方式把当前剩余元素的最大值移动到一端，而当剩余元素减少为0时，排序结束。
 int a[5] = {3, 4, 1, 5, 2};按照从小到大的顺序排列
 1、交换第一趟结果：{3, 1, 4, 2, 5},此时最大值5位于最右边
 2、交换第二趟结果：{1, 3, 2, 4, 5},此时第二大值4位于右边
 3、交换第三趟结果：{1, 2, 3, 4, 5},此时第三大值3位于右边
 4、交换第四趟结果：{1, 2, 3, 4, 5},此时第四大值2位于右边，排序结束
 过程：执行n-1趟，每趟从左到右依次比较相邻的两个数，如果大的数在左边，则交换这两个数，当该趟结束时，该趟最大数被移动到当前剩余数的最右边
*/
void bubbleSort() {
    int a[5] = {3, 4, 1, 5, 2};
    for (int i = 1; i <= 5 - 1; i++) {// 进行n-1趟
        for (int j = 0; j < 5 - i; j++) {// 第i趟时从a[0]到a[n-i-1]都与他们下一个数比较
            if (a[j] > a[j + 1]) {// 如果左边的数更大，则交换a[j]和a[j+1]
                int temp = a[j];
                a[j] = a[j + 1];
                a[j + 1] = temp;
            }
        }
    }
    for (int i = 0; i < 5; i++) {
        printf("%d ",a[i]);
    }
}
